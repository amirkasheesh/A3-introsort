# A3. Introsort

## Codeforces A3i
- **ID посылки:** 348885759

## Описание программы

Программа реализует экспериментальное сравнение двух алгоритмов быстрой сортировки:

- **QuickSort** — стандартный рекурсивный алгоритм быстрой сортировки  
  с *случайным выбором опорного элемента*;
- **IntroSort** — гибридная реализация:
  - базовый алгоритм — QuickSort;
  - при достижении глубины рекурсии `2 · floor(log2(N))` происходит переключение на **HeapSort**;
  - на подмассивах размером `< 16` используется **InsertionSort**.

Такое сочетание позволяет:
- сохранить быструю работу QuickSort на «хороших» данных;
- гарантировать худший случай **O(N log N)** за счёт HeapSort;
- ускорить обработку мелких подмассивов за счёт InsertionSort.

### Генерация данных

Используется тот же генератор массивов `ArrayGenerator`, что и в задаче A2.  
Он создаёт три категории входных данных:

1. **Random** — полностью случайный массив;
2. **Almost** — почти отсортированный массив  
   (упорядоченный массив с небольшой долей соседних обменов);
3. **Reverse** — строго убывающий массив.

Все массивы генерируются детерминированно при фиксированном seed,  
поэтому эксперименты можно воспроизвести.

## Структура репозитория
```
A3-introsort/
├─ src/
│  ├─ main.cpp
│  ├─ array_generator.h
│  ├─ sort_tester.h
│  ├─ results.csv
│  └─ main
├─ docs_results/
│  ├─ Almost_time.png
│  ├─ Almost_boost.png
│  ├─ Random_time.png
│  ├─ Graphics_in_collab.ipynb
│  ├─ Graphics_in_collab.ipynb - Colab.pdf
│  ├─ Random_boost.png
│  ├─ Reverse_time.png
│  └─ Reverse_boost.png
└─ README.md
```

### Замеры времени

Класс `SortTester` выполняет серию замеров времени сортировки для:

- размеров массива от **500** до **100 000** с шагом 100;
- трёх типов входных данных (**Random / Almost / Reverse**);
- двух алгоритмов (**QuickSort**, **IntroSort**);
- **5 повторов** для усреднения результата.

Время измеряется в микросекундах с помощью `std::chrono::high_resolution_clock`.

Результаты сохраняются в файл `results.csv` в формате:

```text
Algorithm,category,size,trial,time_us
```

## Результаты

На основе файла `results.csv` в Google Colab были построены две группы графиков для каждой категории данных (**Random**, **Almost**, **Reverse**):

1. **Графики времени сортировки**  
   Зависимость *среднего времени* работы алгоритмов **QuickSort** и **IntroSort** от размера массива.  
   На этих графиках видно, что:
   - время обоих алгоритмов растет примерно линейно по масштабу эксперимента (O(N log N));
   - кривая **IntroSort** заметно ниже, чем кривая **QuickSort** для всех размеров и всех типов данных;
   - для больших размеров массивов отрыв по времени становится стабильным.

2. **Графики относительного ускорения**  
   Для каждого размера N построено отношение  
   S(N) = \dfrac{T_{QuickSort}(N)}{T_{IntroSort}(N)}  
   На графиках показано:
   - горизонтальная пунктирная линия на уровне 1 соответствует ситуации без выигрыша;
   - реальные кривые лежат **выше 1** на всем диапазоне N, что означает ускорение IntroSort;
   - для почти отсортированных и обратных массивов значение S(N) стабилизируется примерно в диапазоне **1.7–1.9**, а для случайных массивов — около **1.4–1.6**;
   - на малых размерах массивов наблюдаются колебания из‑за погрешностей измерений, но при N ≳ 10 000 поведение становится плавным и устойчивым.

Таким образом, гибридная сортировка с переключением на HeapSort и InsertionSort дает устойчивое ускорение по сравнению с классическим QuickSort.

## Выводы

1. **IntroSort стабильно быстрее QuickSort** на всех типах входных данных и для всех рассмотренных размеров массивов. Ускорение в среднем составляет от 1.5 до 2 раз.
2. Использование **InsertionSort** на маленьких подмассивах уменьшает константы во времени работы и особенно полезно на почти отсортированных данных.
3. Введение ограничения на глубину рекурсии и переход на **HeapSort** защищает от плохих разбиений и потенциального квадратичного времени работы, что повышает предсказуемость и надежность алгоритма.
4. Полученные результаты подтверждают, почему Introsort используется в стандартных библиотеках сортировки: гибридный подход сочетает теоретически хорошую асимптотику и практическую эффективность.
5. Реализованная программа корректно генерирует тесты, выполняет замеры и формирует данные, пригодные для дальнейшего анализа и визуализации.
